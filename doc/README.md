# helpful material

Video:
- https://www.youtube.com/watch?v=u4-rpIlV9NI&list=PLBlnK6fEyqRgp46KUv4ZY69yXmpwKOIev&index=73 # Derivation Tree (Left & Right Derivation Trees) ~ (Neso Academy)
- https://www.youtube.com/watch?v=htoFbcwES28&list=PLBlnK6fEyqRgp46KUv4ZY69yXmpwKOIev&index=72 # Method to find whether a string belong to a Grammar or not ~ (Neso Academy)
- https://www.youtube.com/watch?v=4ejIAmp_Atw&list=PLBlnK6fEyqRgp46KUv4ZY69yXmpwKOIev&index=85 # Pushdown Automata (Introduction) ~ (Neso Academy)
- https://www.youtube.com/watch?v=tH5AOX9929g # Parsing Bottom Up ~ (Computerphile)

Text:
- Dragon Book (compiler parsing bible)

Context:
- https://stackoverflow.com/questions/4316385/why-is-bottom-up-parsing-more-common-than-top-down-parsing

>BNF (and the theory of grammars and such) comes from computational linguistics: folks researching natural language parsing. BNF is a very attractive way of describing a grammar, and so it's natural to want to consume these notation to produce a parser.
>
>Unfortunately, top-down parsing techniques tend to fall over when applied to such notations, because they cannot handle many common cases (e.g., left recursion). This leaves you with the LR family, which performs well and can handle the grammars, and since they're being produced by a machine, who cares what the code looks like?
>
>You're right, though: top-down parsers work more "intuitively," so they're easier to debug and maintain, and once you have a little practice they're just as easy to write as those generated by tools. (Especially when you get into shift/reduce conflict hell.) Many of the answers talk about parsing performance, but in practice top-down parsers can often be optimized to be as fast as machine-generated parsers.

- https://web.cs.dal.ca/~sjackson/lalr1.html # LALR parsing

